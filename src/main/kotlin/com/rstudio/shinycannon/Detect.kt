package com.rstudio.shinycannon

import net.moznion.uribuildertiny.URIBuilderTiny
import org.apache.http.Header
import org.apache.http.client.methods.HttpGet
import org.apache.logging.log4j.Logger
import kotlin.system.exitProcess

enum class ServerType(val typeName: String) {
    RSC("RStudio Server Connect"),
    SSP("Shiny Server or Shiny Server Pro"),
    SAI("shinyapps.io"),
    SHN("R/Shiny"),
    UNK("Unknown")
}

fun typeFromName(typeName: String): ServerType {
    return when (typeName) {
        "RStudio Server Connect" -> ServerType.RSC
        "Shiny Server or Shiny Server Pro" -> ServerType.SSP
        "shinyapps.io" -> ServerType.SAI
        "R/Shiny" -> ServerType.SHN
        "Unknown" -> ServerType.UNK
        else -> error("Unknown server type name in recording: ${typeName}")
    }
}

// Rough heuristic for determining if a response body is markup generated by Shiny.
// We do this instead of parsing the HTML in case the HTML is invalid.
fun hasShinyJs(body: String) = "/shiny(\\.min)?\\.js[\"']".toRegex().containsMatchIn(body)

fun servedBy(appUrl: String, logger: Logger, headers: MutableList<Header> = mutableListOf()): ServerType {
    val url = URIBuilderTiny(appUrl)

    if (url.host.matches("^.*\\.shinyapps\\.io$".toRegex()))
        return ServerType.SAI

    val req = HttpGet(appUrl).addHeaders(headers)
    val resp = slurp(req)

    if (resp.hasHeader("x-ssp-xsrf") || resp.hasCookie("SSP-XSRF")) {
        return ServerType.SSP
    } else if (resp.hasHeader("x-powered-by")) {
        val sspVals = setOf("Express", "Shiny Server", "Shiny Server Pro")
        if (sspVals.contains(resp.getHeader("x-powered-by"))) return ServerType.SSP
    } else if (resp.hasCookie("rscid")) {
        return ServerType.RSC
    }

    if (hasShinyJs(resp.body)) return ServerType.SHN

    logger.error("Target URL ${appUrl} does not appear to be a Shiny application.")
    exitProcess(1)
}